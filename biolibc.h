    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_align_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_ALIGN_MIN_MATCH(ptr)         ((ptr)->min_match)
#define BL_ALIGN_MAX_MISMATCH_PERCENT(ptr) ((ptr)->max_mismatch_percent)

#ifndef _BIOLIBC_ALIGN_H_
#define _BIOLIBC_ALIGN_H_

#ifndef _STDIO_H_
#include <stdio.h>
#endif

typedef struct
{
    size_t min_match;
    unsigned max_mismatch_percent;
}   bl_align_t;


/* align.c */
size_t bl_align_map_seq_sub(const bl_align_t *params, const char *big, size_t big_len, const char *little, size_t little_len);
size_t bl_align_map_seq_exact(const bl_align_t *params, const char *big, size_t big_len, const char *little, size_t little_len);

#endif  // _BIOLIBC_ALIGN_H_

#ifndef _BIOLIBC_H_
#define _BIOLIBC_H_

#ifndef _STDIO_H_
#include <stdio.h>          // FILE
#endif

#ifndef _SYS_STDINT_H_
#include <stdint.h>         // int64_t
#endif

#ifndef _INTTYPES_H_
#include <inttypes.h>       // PRId64
#endif

#define BL_READ_OK              0
#define BL_READ_EOF             -1
#define BL_READ_OVERFLOW        -2
#define BL_READ_TRUNCATED       -3
#define BL_READ_GFF_TERMINATOR  -4
#define BL_READ_EXTRA_COLS      -5
#define BL_READ_MISMATCH        -6
#define BL_READ_BAD_DATA        -7
#define BL_READ_UNKNOWN_FORMAT  -8

#define BL_WRITE_OK             0
#define BL_WRITE_FAILURE        -1

// Replace these with class-specific constants
//#define BL_DATA_OK              0
//#define BL_DATA_INVALID         -1      // Catch-all for non-specific error
//#define BL_DATA_OUT_OF_RANGE    -2

#define BL_CHROM_MAX_CHARS      256
#define BL_POSITION_MAX_DIGITS  32

#define BL_CMD_MAX              4096    // Arbitrary

#endif  // _BIOLIBC_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_align_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-align-mutators.c */
int bl_align_set_min_match(bl_align_t *bl_align_ptr, size_t new_min_match);
int bl_align_set_max_mismatch_percent(bl_align_t *bl_align_ptr, unsigned new_max_mismatch_percent);

/* Return values for mutator functions */
#define BL_ALIGN_DATA_OK              0
#define BL_ALIGN_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_ALIGN_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_bed_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_BED_CHROM(ptr)               ((ptr)->chrom)
#define BL_BED_CHROM_AE(ptr,c)          ((ptr)->chrom[c])
#define BL_BED_CHROM_START(ptr)         ((ptr)->chrom_start)
#define BL_BED_CHROM_END(ptr)           ((ptr)->chrom_end)
#define BL_BED_NAME(ptr)                ((ptr)->name)
#define BL_BED_NAME_AE(ptr,c)           ((ptr)->name[c])
#define BL_BED_SCORE(ptr)               ((ptr)->score)
#define BL_BED_STRAND(ptr)              ((ptr)->strand)
#define BL_BED_THICK_START(ptr)         ((ptr)->thick_start)
#define BL_BED_THICK_END(ptr)           ((ptr)->thick_end)
#define BL_BED_ITEM_RGB(ptr)            ((ptr)->item_rgb)
#define BL_BED_ITEM_RGB_AE(ptr,c)       ((ptr)->item_rgb[c])
#define BL_BED_BLOCK_COUNT(ptr)         ((ptr)->block_count)
#define BL_BED_BLOCK_SIZES(ptr)         ((ptr)->block_sizes)
#define BL_BED_BLOCK_SIZES_AE(ptr,c)    ((ptr)->block_sizes[c])
#define BL_BED_BLOCK_STARTS(ptr)        ((ptr)->block_starts)
#define BL_BED_BLOCK_STARTS_AE(ptr,c)   ((ptr)->block_starts[c])
#define BL_BED_FIELDS(ptr)              ((ptr)->fields)
#ifndef _BIOLIBC_BED_H_
#define _BIOLIBC_BED_H_

#ifndef _BIOLIBC_H_
#endif

#define BL_BED_NAME_MAX_CHARS          256
#define BL_BED_SCORE_MAX_DIGITS        4   // 0 to 1000
#define BL_BED_STRAND_MAX_CHARS        2
#define BL_BED_ITEM_RGB_MAX_CHARS      11  // 255,255,255
#define BL_BED_BLOCK_COUNT_MAX_DIGITS  5
#define BL_BED_BLOCK_SIZE_MAX_DIGITS   20  // 2^64
#define BL_BED_BLOCK_START_MAX_DIGITS  20  // 2^64

#define BL_BED_INIT \
    { "", 0, 0, "", 0, '.', 0, 0, "", 0, NULL, NULL, 0 }

typedef struct
{
    char            chrom[BL_CHROM_MAX_CHARS + 1];
    /*
     *      12345
     *      ACCGT
     *      01234
     *
     *      chr1 0 5
     */
    int64_t         chrom_start,
            chrom_end;
    char            name[BL_BED_NAME_MAX_CHARS + 1];
    unsigned short  score;      // aggs:0:1000
    char            strand;
    int64_t         thick_start,
            thick_end;
    // FIXME: Store RGB in a more compact format
    char            item_rgb[BL_BED_ITEM_RGB_MAX_CHARS+1];
    unsigned short  block_count;
    int64_t         *block_sizes;
    int64_t         *block_starts;

    // Not part of BED spec
    unsigned short  fields;     // aggs:3:9
}   bl_bed_t;

typedef unsigned int            bed_field_mask_t;

/*
 *  Chromosome, start, and end are required so no mask bits are defined
 */
#define BL_BED_FIELD_NAME      0x01
#define BL_BED_FIELD_SCORE     0x02
#define BL_BED_FIELD_STRAND    0x04
#define BL_BED_FIELD_THICK     0X08
#define BL_BED_FIELD_RGB       0x10
#define BL_BED_FIELD_BLOCK     0x20
#define BL_BED_FIELD_ALL       0xff

// After bl_bed_t def for prototypes
#ifndef _BIOLIBC_GFF_H_
#endif

#ifndef _BIOLIBC_GFF_H_
#define _BIOLIBC_GFF_H_

#ifndef _BIOLIBC_H_
#endif

#define BL_GFF_SOURCE_MAX_CHARS     1024     // Guess
#define BL_GFF_TYPE_MAX_CHARS       256      // Guess
#define BL_GFF_SCORE_MAX_DIGITS     64       // Floating point
#define BL_GFF_STRAND_MAX_CHARS     2
#define BL_GFF_LINE_MAX_CHARS       32768
#define BL_GFF_PHASE_MAX_DIGITS     2

#define BL_GFF_SCORE_UNAVAILABLE    -1.0
#define BL_GFF_PHASE_UNAVAILABLE    '.'

typedef struct
{
    char            seqid[BL_CHROM_MAX_CHARS + 1];
    char            source[BL_GFF_SOURCE_MAX_CHARS + 1];
    char            type[BL_GFF_TYPE_MAX_CHARS + 1];
    int64_t         start,
            end;
    double          score;
    char            strand;         // '+' or '-' or '.'
    char            phase;          // 0, 1, 2, or '.' (bases to condon start)
    char            *attributes;    // Ensembl ID, Name, etc.
    size_t          attributes_array_size;
    size_t          attributes_len;
    
    /*
     *  Fields below are not part of GFF.  They are extracted from attributes
     *  because they are frequently useful.
     */
    char            *feature_id;    // In every feature of Ensemble GFFs
    char            *feature_name;  // Extract from gene features and look
                    // up using Ensemble ID for others
    char            *feature_parent;    // Transcripts, exons, etc.
    
    // Offset of the feature in the GFF file for indexing
    long            file_pos;
}   bl_gff_t;

typedef unsigned int            gff_field_mask_t;

#define BL_GFF_FIELD_SEQID      0x001
#define BL_GFF_FIELD_SOURCE     0x002
#define BL_GFF_FIELD_TYPE       0x004
#define BL_GFF_FIELD_START      0x008
#define BL_GFF_FIELD_END        0x010
#define BL_GFF_FIELD_SCORE      0x020
#define BL_GFF_FIELD_STRAND     0x040
#define BL_GFF_FIELD_PHASE      0x080
#define BL_GFF_FIELD_ATTRIBUTES 0x100
#define BL_GFF_FIELD_ALL        0xfff

// After bl_gff_t for prototypes
#ifndef _BIOLIBC_BED_H_
#endif

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_gff_index_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_GFF_INDEX_ARRAY_SIZE(ptr)    ((ptr)->array_size)
#define BL_GFF_INDEX_COUNT(ptr)         ((ptr)->count)
#define BL_GFF_INDEX_FILE_POS(ptr)      ((ptr)->file_pos)
#define BL_GFF_INDEX_FILE_POS_AE(ptr,c) ((ptr)->file_pos[c])
#define BL_GFF_INDEX_SEQID(ptr)         ((ptr)->seqid)
#define BL_GFF_INDEX_SEQID_AE(ptr,c)    ((ptr)->seqid[c])
#define BL_GFF_INDEX_START(ptr)         ((ptr)->start)
#define BL_GFF_INDEX_START_AE(ptr,c)    ((ptr)->start[c])
#define BL_GFF_INDEX_END(ptr)           ((ptr)->end)
#define BL_GFF_INDEX_END_AE(ptr,c)      ((ptr)->end[c])
#ifndef _BIOLIBC_GFF_INDEX_H_
#define _BIOLIBC_GFF_INDEX_H_

#ifndef _STDIO_H_
#include <stdio.h>
#endif

#ifndef _INTTYPES_H_
#include <inttypes.h>
#endif

#ifndef _BIOLIBC_GFF_H_
#endif

#define BL_GFF_INDEX_INIT { 0, 0, NULL, NULL }

#define BL_GFF_INDEX_OK             0
#define BL_GFF_INDEX_MALLOC_FAILED  -1
#define BL_GFF_INDEX_BAD_ARG        -2

typedef struct
{
    size_t      array_size;
    size_t      count;
    long        *file_pos;  // Return type of ftell()
    char        **seqid;
    int64_t     *start;
    int64_t     *end;
}   bl_gff_index_t;


int bl_gff_index_add(bl_gff_index_t *gi, bl_gff_t *feature);
int bl_gff_index_seek_reverse(bl_gff_index_t *gi, FILE *stream, bl_gff_t *feature, int64_t gene_count, int64_t max_nt);

#endif  // _BIOLIBC_GFF_INDEX_H_

#ifndef _BIOLIBC_OVERLAP_H_
#define _BIOLIBC_OVERLAP_H_

#ifndef _STDIO_H_
#include <stdio.h>
#endif

#ifndef _INTTYPES_H_
#include <inttypes.h>
#endif

#ifndef _BIOLIBC_H_
#endif

// 1-based, inclusive at both ends
typedef struct
{
    int64_t    feature1_len;
    int64_t    feature2_len;
    int64_t    overlap_start;
    int64_t    overlap_end;
    int64_t    overlap_len;
}   bl_overlap_t;


/* overlap.c */
int bl_overlap_set_all(bl_overlap_t *overlap, int64_t feature1_len, int64_t feature2_len, int64_t overlap_start, int64_t overlap_end);
int bl_overlap_print(bl_overlap_t *overlap, FILE *stream, char *feature1_name, char *feature2_name);

#endif // _BIOLIBC_OVERLAP_H_

#ifndef _bl_overlap_h
#endif


/* bed.c */
FILE *bl_bed_skip_header(FILE *bed_stream);
int bl_bed_read(bl_bed_t *bed_feature, FILE *bed_stream, bed_field_mask_t field_mask);
int bl_bed_write(bl_bed_t *bed_feature, FILE *bed_stream, bed_field_mask_t field_mask);
void bl_bed_check_order(bl_bed_t *bed_feature, char last_chrom[], int64_t last_start);
int bl_bed_gff_cmp(bl_bed_t *bed_feature, bl_gff_t *gff_feature, bl_overlap_t *overlap);

#endif  // _BIOLIBC_BED_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_bed_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-bed-mutators.c */
int bl_bed_set_chrom_ae(bl_bed_t *bl_bed_ptr, size_t c, char new_chrom_element);
int bl_bed_set_chrom_cpy(bl_bed_t *bl_bed_ptr, char new_chrom[], size_t array_size);
int bl_bed_set_chrom_start(bl_bed_t *bl_bed_ptr, int64_t new_chrom_start);
int bl_bed_set_chrom_end(bl_bed_t *bl_bed_ptr, int64_t new_chrom_end);
int bl_bed_set_name_ae(bl_bed_t *bl_bed_ptr, size_t c, char new_name_element);
int bl_bed_set_name_cpy(bl_bed_t *bl_bed_ptr, char new_name[], size_t array_size);
int bl_bed_set_score(bl_bed_t *bl_bed_ptr, unsigned short new_score);
int bl_bed_set_strand(bl_bed_t *bl_bed_ptr, char new_strand);
int bl_bed_set_thick_start(bl_bed_t *bl_bed_ptr, int64_t new_thick_start);
int bl_bed_set_thick_end(bl_bed_t *bl_bed_ptr, int64_t new_thick_end);
int bl_bed_set_item_rgb_ae(bl_bed_t *bl_bed_ptr, size_t c, char new_item_rgb_element);
int bl_bed_set_item_rgb_cpy(bl_bed_t *bl_bed_ptr, char new_item_rgb[], size_t array_size);
int bl_bed_set_block_count(bl_bed_t *bl_bed_ptr, unsigned short new_block_count);
int bl_bed_set_block_sizes(bl_bed_t *bl_bed_ptr, int64_t *new_block_sizes);
int bl_bed_set_block_sizes_ae(bl_bed_t *bl_bed_ptr, size_t c, int64_t new_block_sizes_element);
int bl_bed_set_block_sizes_cpy(bl_bed_t *bl_bed_ptr, int64_t *new_block_sizes, size_t array_size);
int bl_bed_set_block_starts(bl_bed_t *bl_bed_ptr, int64_t *new_block_starts);
int bl_bed_set_block_starts_ae(bl_bed_t *bl_bed_ptr, size_t c, int64_t new_block_starts_element);
int bl_bed_set_block_starts_cpy(bl_bed_t *bl_bed_ptr, int64_t *new_block_starts, size_t array_size);
int bl_bed_set_fields(bl_bed_t *bl_bed_ptr, unsigned short new_fields);

/* Return values for mutator functions */
#define BL_BED_DATA_OK              0
#define BL_BED_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_BED_DATA_OUT_OF_RANGE    -2

#ifndef _BIOLIBC_STRING_H_
#define _BIOLIBC_STRING_H_

int     bl_chrom_name_cmp(const char *n1, const char *n2);

#endif  // _BIOLIBC_STRING_H_
    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_fasta_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_FASTA_DESC(ptr)              ((ptr)->desc)
#define BL_FASTA_DESC_AE(ptr,c)         ((ptr)->desc[c])
#define BL_FASTA_SEQ(ptr)               ((ptr)->seq)
#define BL_FASTA_SEQ_AE(ptr,c)          ((ptr)->seq[c])
#define BL_FASTA_DESC_ARRAY_SIZE(ptr)   ((ptr)->desc_array_size)
#define BL_FASTA_SEQ_ARRAY_SIZE(ptr)    ((ptr)->seq_array_size)
#define BL_FASTA_DESC_LEN(ptr)          ((ptr)->desc_len)
#define BL_FASTA_SEQ_LEN(ptr)           ((ptr)->seq_len)

#ifndef _BIOLIBC_FASTA_H_
#define _BIOLIBC_FASTA_H_

#ifndef _BIOLIBC_H_
#endif

typedef struct
{
    char    *desc;
    char    *seq;
    size_t  desc_array_size,
        seq_array_size,
        desc_len,
        seq_len;
}   bl_fasta_t;

#define BL_FASTA_INIT           { NULL, NULL, 0, 0, 0, 0 }
#define BL_FASTA_LINE_UNLIMITED 0


/* fasta.c */
int bl_fasta_read(bl_fasta_t *record, FILE *fasta_stream);
int bl_fasta_write(bl_fasta_t *record, FILE *fasta_stream, size_t chars_per_line);
void bl_fasta_free(bl_fasta_t *record);
void bl_fasta_init(bl_fasta_t *record);

#endif // _BIOLIBC_FASTA_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_fasta_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-fasta-mutators.c */
int bl_fasta_set_desc(bl_fasta_t *bl_fasta_ptr, char *new_desc);
int bl_fasta_set_desc_ae(bl_fasta_t *bl_fasta_ptr, size_t c, char new_desc_element);
int bl_fasta_set_desc_cpy(bl_fasta_t *bl_fasta_ptr, char *new_desc, size_t array_size);
int bl_fasta_set_seq(bl_fasta_t *bl_fasta_ptr, char *new_seq);
int bl_fasta_set_seq_ae(bl_fasta_t *bl_fasta_ptr, size_t c, char new_seq_element);
int bl_fasta_set_seq_cpy(bl_fasta_t *bl_fasta_ptr, char *new_seq, size_t array_size);
int bl_fasta_set_desc_array_size(bl_fasta_t *bl_fasta_ptr, size_t new_desc_array_size);
int bl_fasta_set_seq_array_size(bl_fasta_t *bl_fasta_ptr, size_t new_seq_array_size);
int bl_fasta_set_desc_len(bl_fasta_t *bl_fasta_ptr, size_t new_desc_len);
int bl_fasta_set_seq_len(bl_fasta_t *bl_fasta_ptr, size_t new_seq_len);

/* Return values for mutator functions */
#define BL_FASTA_DATA_OK              0
#define BL_FASTA_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_FASTA_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_fastq_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_FASTQ_DESC(ptr)              ((ptr)->desc)
#define BL_FASTQ_DESC_AE(ptr,c)         ((ptr)->desc[c])
#define BL_FASTQ_SEQ(ptr)               ((ptr)->seq)
#define BL_FASTQ_SEQ_AE(ptr,c)          ((ptr)->seq[c])
#define BL_FASTQ_PLUS(ptr)              ((ptr)->plus)
#define BL_FASTQ_PLUS_AE(ptr,c)         ((ptr)->plus[c])
#define BL_FASTQ_QUAL(ptr)              ((ptr)->qual)
#define BL_FASTQ_QUAL_AE(ptr,c)         ((ptr)->qual[c])
#define BL_FASTQ_DESC_ARRAY_SIZE(ptr)   ((ptr)->desc_array_size)
#define BL_FASTQ_SEQ_ARRAY_SIZE(ptr)    ((ptr)->seq_array_size)
#define BL_FASTQ_PLUS_ARRAY_SIZE(ptr)   ((ptr)->plus_array_size)
#define BL_FASTQ_QUAL_ARRAY_SIZE(ptr)   ((ptr)->qual_array_size)
#define BL_FASTQ_DESC_LEN(ptr)          ((ptr)->desc_len)
#define BL_FASTQ_SEQ_LEN(ptr)           ((ptr)->seq_len)
#define BL_FASTQ_PLUS_LEN(ptr)          ((ptr)->plus_len)
#define BL_FASTQ_QUAL_LEN(ptr)          ((ptr)->qual_len)

#ifndef _BIOLIBC_FASTQ_H_
#define _BIOLIBC_FASTQ_H_

#ifndef _BIOLIBC_H_
#endif

typedef struct
{
    char    *desc,
        *seq,
        *plus,
        *qual;
    size_t  desc_array_size,
        seq_array_size,
        plus_array_size,
        qual_array_size,
        desc_len,
        seq_len,
        plus_len,
        qual_len;
}   bl_fastq_t;

#define BL_FASTQ_INIT           { NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0 }

// Must be same as BL_FASTA_LINE_UNLIMITED
#define BL_FASTQ_LINE_UNLIMITED 0


/* fastq.c */
int bl_fastq_read(bl_fastq_t *record, FILE *fastq_stream);
int bl_fastq_write(bl_fastq_t *record, FILE *fastq_stream, size_t max_line_len);
void bl_fastq_free(bl_fastq_t *record);
void bl_fastq_init(bl_fastq_t *record);
size_t bl_fastq_find_adapter_smart(const bl_fastq_t *read, const char *adapter, size_t min_match, unsigned max_mismatch_percent);
size_t bl_fastq_find_adapter_exact(const bl_fastq_t *read, const char *adapter, size_t min_match, unsigned max_mismatch_percent);
size_t bl_fastq_3p_trim(bl_fastq_t *read, size_t new_len);
size_t bl_fastq_find_3p_low_qual(const bl_fastq_t *read, unsigned min_qual, unsigned phred_base);
size_t bl_fastq_name_cmp(bl_fastq_t *read1, bl_fastq_t *read2);

#endif  // _BIOLIBC_FASTQ_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_fastq_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-fastq-mutators.c */
int bl_fastq_set_desc(bl_fastq_t *bl_fastq_ptr, char *new_desc);
int bl_fastq_set_desc_ae(bl_fastq_t *bl_fastq_ptr, size_t c, char new_desc_element);
int bl_fastq_set_desc_cpy(bl_fastq_t *bl_fastq_ptr, char *new_desc, size_t array_size);
int bl_fastq_set_seq(bl_fastq_t *bl_fastq_ptr, char *new_seq);
int bl_fastq_set_seq_ae(bl_fastq_t *bl_fastq_ptr, size_t c, char new_seq_element);
int bl_fastq_set_seq_cpy(bl_fastq_t *bl_fastq_ptr, char *new_seq, size_t array_size);
int bl_fastq_set_plus(bl_fastq_t *bl_fastq_ptr, char *new_plus);
int bl_fastq_set_plus_ae(bl_fastq_t *bl_fastq_ptr, size_t c, char new_plus_element);
int bl_fastq_set_plus_cpy(bl_fastq_t *bl_fastq_ptr, char *new_plus, size_t array_size);
int bl_fastq_set_qual(bl_fastq_t *bl_fastq_ptr, char *new_qual);
int bl_fastq_set_qual_ae(bl_fastq_t *bl_fastq_ptr, size_t c, char new_qual_element);
int bl_fastq_set_qual_cpy(bl_fastq_t *bl_fastq_ptr, char *new_qual, size_t array_size);
int bl_fastq_set_desc_array_size(bl_fastq_t *bl_fastq_ptr, size_t new_desc_array_size);
int bl_fastq_set_seq_array_size(bl_fastq_t *bl_fastq_ptr, size_t new_seq_array_size);
int bl_fastq_set_plus_array_size(bl_fastq_t *bl_fastq_ptr, size_t new_plus_array_size);
int bl_fastq_set_qual_array_size(bl_fastq_t *bl_fastq_ptr, size_t new_qual_array_size);
int bl_fastq_set_desc_len(bl_fastq_t *bl_fastq_ptr, size_t new_desc_len);
int bl_fastq_set_seq_len(bl_fastq_t *bl_fastq_ptr, size_t new_seq_len);
int bl_fastq_set_plus_len(bl_fastq_t *bl_fastq_ptr, size_t new_plus_len);
int bl_fastq_set_qual_len(bl_fastq_t *bl_fastq_ptr, size_t new_qual_len);

/* Return values for mutator functions */
#define BL_FASTQ_DATA_OK              0
#define BL_FASTQ_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_FASTQ_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_fastx_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_FASTX_FORMAT(ptr)            ((ptr)->format)
#define BL_FASTX_FASTA(ptr)             ((ptr)->fasta)
#define BL_FASTX_FASTQ(ptr)             ((ptr)->fastq)

#ifndef _BIOLIBC_FASTA_H_
#endif

#ifndef _BIOLIBC_FASTQ_H_
#endif

typedef struct
{
    int     format;
    union
    {
    bl_fasta_t  fasta;
    bl_fastq_t  fastq;
    };
}   bl_fastx_t;

#define BL_FASTX_FORMAT_UNKNOWN 0
#define BL_FASTX_FORMAT_FASTA   1
#define BL_FASTX_FORMAT_FASTQ   2

#define BL_FASTX_INIT           { BL_FASTX_FORMAT_UNKNOWN }

#define BL_FASTX_LINE_UNLIMITED BL_FASTA_LINE_UNLIMITED


/* fastx.c */
int bl_fastx_read(bl_fastx_t *record, FILE *fastx_stream);
int bl_fastx_write(bl_fastx_t *record, FILE *fastx_stream, size_t max_line_len);
void bl_fastx_free(bl_fastx_t *record);
void bl_fastx_init(bl_fastx_t *record, FILE *fastx_stream);
char *bl_fastx_desc(bl_fastx_t *record);
size_t bl_fastx_desc_len(bl_fastx_t *record);
char *bl_fastx_seq(bl_fastx_t *record);
size_t bl_fastx_seq_len(bl_fastx_t *record);
char *bl_fastx_plus(bl_fastx_t *record);
size_t bl_fastx_plus_len(bl_fastx_t *record);
char *bl_fastx_qual(bl_fastx_t *record);
size_t bl_fastx_qual_len(bl_fastx_t *record);

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_fastx_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-fastx-mutators.c */
int bl_fastx_set_format(bl_fastx_t *bl_fastx_ptr, int new_format);
int bl_fastx_set_fasta(bl_fastx_t *bl_fastx_ptr, bl_fasta_t new_fasta);
int bl_fastx_set_fastq(bl_fastx_t *bl_fastx_ptr, bl_fastq_t new_fastq);

/* Return values for mutator functions */
#define BL_FASTX_DATA_OK              0
#define BL_FASTX_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_FASTX_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_gff_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_GFF_SEQID(ptr)               ((ptr)->seqid)
#define BL_GFF_SEQID_AE(ptr,c)          ((ptr)->seqid[c])
#define BL_GFF_SOURCE(ptr)              ((ptr)->source)
#define BL_GFF_SOURCE_AE(ptr,c)         ((ptr)->source[c])
#define BL_GFF_TYPE(ptr)                ((ptr)->type)
#define BL_GFF_TYPE_AE(ptr,c)           ((ptr)->type[c])
#define BL_GFF_START(ptr)               ((ptr)->start)
#define BL_GFF_END(ptr)                 ((ptr)->end)
#define BL_GFF_SCORE(ptr)               ((ptr)->score)
#define BL_GFF_STRAND(ptr)              ((ptr)->strand)
#define BL_GFF_PHASE(ptr)               ((ptr)->phase)
#define BL_GFF_ATTRIBUTES(ptr)          ((ptr)->attributes)
#define BL_GFF_ATTRIBUTES_AE(ptr,c)     ((ptr)->attributes[c])
#define BL_GFF_ATTRIBUTES_ARRAY_SIZE(ptr) ((ptr)->attributes_array_size)
#define BL_GFF_ATTRIBUTES_LEN(ptr)      ((ptr)->attributes_len)
#define BL_GFF_FEATURE_ID(ptr)          ((ptr)->feature_id)
#define BL_GFF_FEATURE_ID_AE(ptr,c)     ((ptr)->feature_id[c])
#define BL_GFF_FEATURE_NAME(ptr)        ((ptr)->feature_name)
#define BL_GFF_FEATURE_NAME_AE(ptr,c)   ((ptr)->feature_name[c])
#define BL_GFF_FEATURE_PARENT(ptr)      ((ptr)->feature_parent)
#define BL_GFF_FEATURE_PARENT_AE(ptr,c) ((ptr)->feature_parent[c])
#define BL_GFF_FILE_POS(ptr)            ((ptr)->file_pos)

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_gff_index_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-gff-index-mutators.c */
int bl_gff_index_set_array_size(bl_gff_index_t *bl_gff_index_ptr, size_t new_array_size);
int bl_gff_index_set_count(bl_gff_index_t *bl_gff_index_ptr, size_t new_count);
int bl_gff_index_set_file_pos(bl_gff_index_t *bl_gff_index_ptr, long *new_file_pos);
int bl_gff_index_set_file_pos_ae(bl_gff_index_t *bl_gff_index_ptr, size_t c, long new_file_pos_element);
int bl_gff_index_set_file_pos_cpy(bl_gff_index_t *bl_gff_index_ptr, long *new_file_pos, size_t array_size);
int bl_gff_index_set_seqid(bl_gff_index_t *bl_gff_index_ptr, char **new_seqid);
int bl_gff_index_set_seqid_ae(bl_gff_index_t *bl_gff_index_ptr, size_t c, char *new_seqid_element);
int bl_gff_index_set_seqid_cpy(bl_gff_index_t *bl_gff_index_ptr, char **new_seqid, size_t array_size);
int bl_gff_index_set_start(bl_gff_index_t *bl_gff_index_ptr, int64_t *new_start);
int bl_gff_index_set_start_ae(bl_gff_index_t *bl_gff_index_ptr, size_t c, int64_t new_start_element);
int bl_gff_index_set_start_cpy(bl_gff_index_t *bl_gff_index_ptr, int64_t *new_start, size_t array_size);
int bl_gff_index_set_end(bl_gff_index_t *bl_gff_index_ptr, int64_t *new_end);
int bl_gff_index_set_end_ae(bl_gff_index_t *bl_gff_index_ptr, size_t c, int64_t new_end_element);
int bl_gff_index_set_end_cpy(bl_gff_index_t *bl_gff_index_ptr, int64_t *new_end, size_t array_size);

/* Return values for mutator functions */
#define BL_GFF_INDEX_DATA_OK              0
#define BL_GFF_INDEX_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_GFF_INDEX_DATA_OUT_OF_RANGE    -2


/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_gff_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-gff-mutators.c */
int bl_gff_set_seqid_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_seqid_element);
int bl_gff_set_seqid_cpy(bl_gff_t *bl_gff_ptr, char new_seqid[], size_t array_size);
int bl_gff_set_source_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_source_element);
int bl_gff_set_source_cpy(bl_gff_t *bl_gff_ptr, char new_source[], size_t array_size);
int bl_gff_set_type_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_type_element);
int bl_gff_set_type_cpy(bl_gff_t *bl_gff_ptr, char new_type[], size_t array_size);
int bl_gff_set_start(bl_gff_t *bl_gff_ptr, int64_t new_start);
int bl_gff_set_end(bl_gff_t *bl_gff_ptr, int64_t new_end);
int bl_gff_set_score(bl_gff_t *bl_gff_ptr, double new_score);
int bl_gff_set_strand(bl_gff_t *bl_gff_ptr, char new_strand);
int bl_gff_set_phase(bl_gff_t *bl_gff_ptr, char new_phase);
int bl_gff_set_attributes(bl_gff_t *bl_gff_ptr, char *new_attributes);
int bl_gff_set_attributes_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_attributes_element);
int bl_gff_set_attributes_cpy(bl_gff_t *bl_gff_ptr, char *new_attributes, size_t array_size);
int bl_gff_set_attributes_array_size(bl_gff_t *bl_gff_ptr, size_t new_attributes_array_size);
int bl_gff_set_attributes_len(bl_gff_t *bl_gff_ptr, size_t new_attributes_len);
int bl_gff_set_feature_id(bl_gff_t *bl_gff_ptr, char *new_feature_id);
int bl_gff_set_feature_id_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_feature_id_element);
int bl_gff_set_feature_id_cpy(bl_gff_t *bl_gff_ptr, char *new_feature_id, size_t array_size);
int bl_gff_set_feature_name(bl_gff_t *bl_gff_ptr, char *new_feature_name);
int bl_gff_set_feature_name_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_feature_name_element);
int bl_gff_set_feature_name_cpy(bl_gff_t *bl_gff_ptr, char *new_feature_name, size_t array_size);
int bl_gff_set_feature_parent(bl_gff_t *bl_gff_ptr, char *new_feature_parent);
int bl_gff_set_feature_parent_ae(bl_gff_t *bl_gff_ptr, size_t c, char new_feature_parent_element);
int bl_gff_set_feature_parent_cpy(bl_gff_t *bl_gff_ptr, char *new_feature_parent, size_t array_size);
int bl_gff_set_file_pos(bl_gff_t *bl_gff_ptr, long new_file_pos);

/* Return values for mutator functions */
#define BL_GFF_DATA_OK              0
#define BL_GFF_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_GFF_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_overlap_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_OVERLAP_FEATURE1_LEN(ptr)    ((ptr)->feature1_len)
#define BL_OVERLAP_FEATURE2_LEN(ptr)    ((ptr)->feature2_len)
#define BL_OVERLAP_OVERLAP_START(ptr)   ((ptr)->overlap_start)
#define BL_OVERLAP_OVERLAP_END(ptr)     ((ptr)->overlap_end)
#define BL_OVERLAP_OVERLAP_LEN(ptr)     ((ptr)->overlap_len)

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_overlap_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-overlap-mutators.c */
int bl_overlap_set_feature1_len(bl_overlap_t *bl_overlap_ptr, int64_t new_feature1_len);
int bl_overlap_set_feature2_len(bl_overlap_t *bl_overlap_ptr, int64_t new_feature2_len);
int bl_overlap_set_overlap_start(bl_overlap_t *bl_overlap_ptr, int64_t new_overlap_start);
int bl_overlap_set_overlap_end(bl_overlap_t *bl_overlap_ptr, int64_t new_overlap_end);
int bl_overlap_set_overlap_len(bl_overlap_t *bl_overlap_ptr, int64_t new_overlap_len);

/* Return values for mutator functions */
#define BL_OVERLAP_DATA_OK              0
#define BL_OVERLAP_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_OVERLAP_DATA_OUT_OF_RANGE    -2

    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_pos_list_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_POS_LIST_ARRAY_SIZE(ptr)     ((ptr)->array_size)
#define BL_POS_LIST_COUNT(ptr)          ((ptr)->count)
#define BL_POS_LIST_POSITIONS(ptr)      ((ptr)->positions)
#define BL_POS_LIST_POSITIONS_AE(ptr,c) ((ptr)->positions[c])

#ifndef _BIOLIBC_POS_LIST_H_
#define _BIOLIBC_POS_LIST_H_

#ifndef _STDIO_H_
#include <stdio.h>
#endif

#ifndef _STDINT_H_
#include <stdint.h>
#endif

#ifndef _BIOLIBC_H_
#endif

#define BL_POS_LIST_INIT  { 0, 0, NULL };

typedef struct
{
    size_t      array_size;
    size_t      count;
    int64_t    *positions;
}   bl_pos_list_t;

typedef int bl_pos_list_sort_order_t;

#define BL_POS_LIST_ASCENDING  0
#define BL_POS_LIST_DESCENDING 1


/* pos-list.c */
void bl_pos_list_allocate(bl_pos_list_t *pos_list, size_t array_size);
void bl_pos_list_free(bl_pos_list_t *pos_list);
int bl_pos_list_add_position(bl_pos_list_t *pos_list, int64_t position);
int bl_pos_list_from_csv(bl_pos_list_t *pos_list, const char *bounds_str, size_t array_size);
int position_cmp_ascending(const int64_t *pos1, const int64_t *pos2);
int position_cmp_descending(const int64_t *pos1, const int64_t *pos2);
void bl_pos_list_sort(bl_pos_list_t *pos_list, bl_pos_list_sort_order_t order);

#endif  // _BIOLIBC_POS_LIST_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_pos_list_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-pos-list-mutators.c */
int bl_pos_list_set_array_size(bl_pos_list_t *bl_pos_list_ptr, size_t new_array_size);
int bl_pos_list_set_count(bl_pos_list_t *bl_pos_list_ptr, size_t new_count);
int bl_pos_list_set_positions(bl_pos_list_t *bl_pos_list_ptr, int64_t *new_positions);
int bl_pos_list_set_positions_ae(bl_pos_list_t *bl_pos_list_ptr, size_t c, int64_t new_positions_element);
int bl_pos_list_set_positions_cpy(bl_pos_list_t *bl_pos_list_ptr, int64_t *new_positions, size_t array_size);

/* Return values for mutator functions */
#define BL_POS_LIST_DATA_OK              0
#define BL_POS_LIST_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_POS_LIST_DATA_OUT_OF_RANGE    -2

#ifndef _BIOLIBC_SAM_H_
#define _BIOLIBC_SAM_H_

#ifndef _INTTYPES_H
#include <inttypes.h>
#endif

#ifndef _BIOLIBC_H_
#endif

#define BL_SAM_MAPQ_MAX_CHARS  5
#define BL_SAM_QNAME_MAX_CHARS 4096
#define BL_SAM_RNAME_MAX_CHARS 4096
#define BL_SAM_FLAG_MAX_DIGITS 4096    // What should this really be?

// Keep this for initializing static objects, where we don't want to
// call bl_sam_init() every time.
#define BL_SAM_INIT { "", 0, "", 0, 0, "", "", 0, 0, NULL, NULL, 0, 0, 0, 0 }

typedef struct
{
    /* SAM specification fields.  Meet or exceed published ranges. */
    // Query template (DNA fragment):
    // Same name means likely from the same template
    char            qname[BL_SAM_QNAME_MAX_CHARS + 1];
    
    // Bit flags indicating mapping results
    unsigned        flag;
    
    // Sequence to which mapped (e.g. chromosome)
    char            rname[BL_SAM_RNAME_MAX_CHARS + 1];
    int64_t         pos;
    
    // Mapping quality
    unsigned char   mapq;

    // Be sure to update bl_sam_free if changed to dynamic allocation
    // Alignment report (more detailed info than flag)
    char            *cigar;
    
    // Be sure to update bl_sam_free if changed to dynamic allocation
    // Seq and pos of next read in the template
    char            rnext[BL_SAM_RNAME_MAX_CHARS + 1];
    int64_t         pnext;
    
    long            tlen;   // Template length.  FIXME: Max size?
    
    char            *seq;   // This can be large, so malloc() it
    char            *qual;  // PHRED scores, same length as seq if present
    
    /* Additional data */
    size_t          cigar_array_size,
            cigar_len,
            seq_array_size,
            seq_len,
            qual_array_size,
            qual_len;
}   bl_sam_t;

typedef unsigned int        sam_field_mask_t;

/* Bit flags to select fields in bl_sam_read() or bl_sam_write() */
#define BL_SAM_FIELD_ALL    0xfff
#define BL_SAM_FIELD_QNAME  0x001
#define BL_SAM_FIELD_FLAG   0x002
#define BL_SAM_FIELD_RNAME  0x004
#define BL_SAM_FIELD_POS    0x008
#define BL_SAM_FIELD_MAPQ   0x010
#define BL_SAM_FIELD_CIGAR  0x020
#define BL_SAM_FIELD_RNEXT  0x040
#define BL_SAM_FIELD_PNEXT  0x080
#define BL_SAM_FIELD_TLEN   0x100
#define BL_SAM_FIELD_SEQ    0x200
#define BL_SAM_FIELD_QUAL   0x400

/* Bit flags from SAM specification */
#define BL_SAM_FLAG_PAIRED          0x001
#define BL_SAM_FLAG_PROPER_PAIR     0x002
#define BL_SAM_FLAG_UNMAP           0x004
#define BL_SAM_FLAG_MUNMAP          0x008
#define BL_SAM_FLAG_REVERSE         0x010
#define BL_SAM_FLAG_MREVERSE        0x020
#define BL_SAM_FLAG_READ1           0x040
#define BL_SAM_FLAG_READ2           0x080
#define BL_SAM_FLAG_SECONDARY       0x100
#define BL_SAM_FLAG_QCFAIL          0x200
#define BL_SAM_FLAG_DUP             0x400
#define BL_SAM_FLAG_SUPPLEMENTARY   0x800

#ifndef _BIOLIBC_SAM_H_
#endif
    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_sam_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_SAM_QNAME(ptr)               ((ptr)->qname)
#define BL_SAM_QNAME_AE(ptr,c)          ((ptr)->qname[c])
#define BL_SAM_FLAG(ptr)                ((ptr)->flag)
#define BL_SAM_RNAME(ptr)               ((ptr)->rname)
#define BL_SAM_RNAME_AE(ptr,c)          ((ptr)->rname[c])
#define BL_SAM_POS(ptr)                 ((ptr)->pos)
#define BL_SAM_MAPQ(ptr)                ((ptr)->mapq)
#define BL_SAM_CIGAR(ptr)               ((ptr)->cigar)
#define BL_SAM_CIGAR_AE(ptr,c)          ((ptr)->cigar[c])
#define BL_SAM_RNEXT(ptr)               ((ptr)->rnext)
#define BL_SAM_RNEXT_AE(ptr,c)          ((ptr)->rnext[c])
#define BL_SAM_PNEXT(ptr)               ((ptr)->pnext)
#define BL_SAM_TLEN(ptr)                ((ptr)->tlen)
#define BL_SAM_SEQ(ptr)                 ((ptr)->seq)
#define BL_SAM_SEQ_AE(ptr,c)            ((ptr)->seq[c])
#define BL_SAM_QUAL(ptr)                ((ptr)->qual)
#define BL_SAM_QUAL_AE(ptr,c)           ((ptr)->qual[c])
#define BL_SAM_CIGAR_ARRAY_SIZE(ptr)    ((ptr)->cigar_array_size)
#define BL_SAM_CIGAR_LEN(ptr)           ((ptr)->cigar_len)
#define BL_SAM_SEQ_ARRAY_SIZE(ptr)      ((ptr)->seq_array_size)
#define BL_SAM_SEQ_LEN(ptr)             ((ptr)->seq_len)
#define BL_SAM_QUAL_ARRAY_SIZE(ptr)     ((ptr)->qual_array_size)
#define BL_SAM_QUAL_LEN(ptr)            ((ptr)->qual_len)
    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_sam_buff_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_SAM_BUFF_BUFF_SIZE(ptr)      ((ptr)->buff_size)
#define BL_SAM_BUFF_MAX_ALIGNMENTS(ptr) ((ptr)->max_alignments)
#define BL_SAM_BUFF_ALIGNMENTS(ptr)     ((ptr)->alignments)
#define BL_SAM_BUFF_ALIGNMENTS_AE(ptr,c) ((ptr)->alignments[c])
#define BL_SAM_BUFF_BUFFERED_COUNT(ptr) ((ptr)->buffered_count)
#define BL_SAM_BUFF_MAX_COUNT(ptr)      ((ptr)->max_count)
#define BL_SAM_BUFF_PREVIOUS_POS(ptr)   ((ptr)->previous_pos)
#define BL_SAM_BUFF_PREVIOUS_RNAME(ptr) ((ptr)->previous_rname)
#define BL_SAM_BUFF_PREVIOUS_RNAME_AE(ptr,c) ((ptr)->previous_rname[c])
#define BL_SAM_BUFF_MAPQ_MIN(ptr)       ((ptr)->mapq_min)
#define BL_SAM_BUFF_MAPQ_LOW(ptr)       ((ptr)->mapq_low)
#define BL_SAM_BUFF_MAPQ_HIGH(ptr)      ((ptr)->mapq_high)
#define BL_SAM_BUFF_MAPQ_SUM(ptr)       ((ptr)->mapq_sum)
#define BL_SAM_BUFF_READS_USED(ptr)     ((ptr)->reads_used)
#define BL_SAM_BUFF_TOTAL_ALIGNMENTS(ptr) ((ptr)->total_alignments)
#define BL_SAM_BUFF_TRAILING_ALIGNMENTS(ptr) ((ptr)->trailing_alignments)
#define BL_SAM_BUFF_DISCARDED_ALIGNMENTS(ptr) ((ptr)->discarded_alignments)
#define BL_SAM_BUFF_DISCARDED_SCORE_SUM(ptr) ((ptr)->discarded_score_sum)
#define BL_SAM_BUFF_DISCARDED_TRAILING(ptr) ((ptr)->discarded_trailing)
#define BL_SAM_BUFF_MIN_DISCARDED_SCORE(ptr) ((ptr)->min_discarded_score)
#define BL_SAM_BUFF_MAX_DISCARDED_SCORE(ptr) ((ptr)->max_discarded_score)
#define BL_SAM_BUFF_UNMAPPED_ALIGNMENTS(ptr) ((ptr)->unmapped_alignments)

#ifndef _BIOLIBC_SAM_BUFF_H_
#define _BIOLIBC_SAM_BUFF_H_

// After bl_sam_t def due to mutual recursion
#ifndef _BIOLIBC_SAM_H_
#endif

/* gff.c */
FILE *bl_gff_skip_header(FILE *gff_stream);
int bl_gff_copy_header(FILE *header_stream, FILE *gff_stream);
int bl_gff_read(bl_gff_t *gff_feature, FILE *gff_stream, gff_field_mask_t field_mask);
int bl_gff_write(bl_gff_t *gff_feature, FILE *gff_stream, gff_field_mask_t field_mask);
void bl_gff_to_bed(bl_gff_t *gff_feature, bl_bed_t *bed_feature);
void bl_gff_free(bl_gff_t *gff_feature);
char *bl_gff_extract_attribute(bl_gff_t *feature, const char *attr_name);
void bl_gff_init(bl_gff_t *feature);
bl_gff_t *bl_gff_dup(bl_gff_t *feature);
bl_gff_t *bl_gff_copy(bl_gff_t *copy, bl_gff_t *feature);
int bl_gff_sam_cmp(bl_gff_t *feature, bl_sam_t *alignment);
int64_t bl_gff_sam_overlap(bl_gff_t *feature, bl_sam_t *alignment);

#endif  // _BIOLIBC_GFF_H_

#ifndef __bool_true_false_are_defined
#include <stdbool.h>
#endif



#ifndef _BIOLIBC_H_
#endif

/*
    256k was not enough for a few of the SRA CRAMs.
    NWD976804 needed more than 512k.  Bad data?
    Of 55k samples, only about 11% reached a sam buffer of > 8k.
    Set an upper limit to prevent runaway memory use and error out
    with EX_DATAERR to tell script not to retry.

    From sam-buff-stats script:
    
    Total      54982
    >4096      13723
    >8192       5824
    >16384      2795
    >32768      1612
    >65536       138
    >131072       33
    >262144       12
    >524288        0
*/
#define BL_SAM_BUFF_START_SIZE  4096

#define BL_SAM_BUFF_OK          0
#define BL_SAM_BUFF_ADD_FAILED  1

/*
 *  Copied from htslib/sam.h to avoid an htslib dependency.  It should be
 *  safe to assume this will never change, since changing it would break
 *  all existing SAM/BAM/CRAM files.
 */
#define     BAM_FUNMAP  4

// FIXME: Move this to samio when complete?
typedef struct
{
    size_t      buff_size;
    size_t      max_alignments;
    bl_sam_t    **alignments;
    size_t      buffered_count;
    size_t      max_count;
    int64_t     previous_pos;
    char        previous_rname[BL_SAM_RNAME_MAX_CHARS + 1];
    
    // Use 64 bits to accommodate large sums
    int64_t     mapq_min,
        mapq_low,
        mapq_high,
        mapq_sum,
        reads_used,
        total_alignments,
        trailing_alignments,
        discarded_alignments,
        discarded_score_sum,
        discarded_trailing,
        min_discarded_score,
        max_discarded_score,
        unmapped_alignments;
}   bl_sam_buff_t;

/* Not generated by gen-get-set */
#define BL_SAM_BUFF_INC_TOTAL_ALIGNMENTS(b)    (++(b)->total_alignments)
#define BL_SAM_BUFF_INC_TRAILING_ALIGNMENTS(b) (++(b)->trailing_alignments)
#define BL_SAM_BUFF_INC_DISCARDED_TRAILING(b)  (++(b)->discarded_trailing)


/* sam-buff.c */
void bl_sam_buff_check_order(bl_sam_buff_t *sam_buff, bl_sam_t *sam_alignment);
void bl_sam_buff_init(bl_sam_buff_t *sam_buff, unsigned int mapq_min, size_t max_alignments);
int bl_sam_buff_add_alignment(bl_sam_buff_t *sam_buff, bl_sam_t *sam_alignment);
void bl_sam_buff_out_of_order(bl_sam_buff_t *sam_buff, bl_sam_t *sam_alignment);
void bl_sam_buff_free_alignment(bl_sam_buff_t *sam_buff, size_t c);
void bl_sam_buff_shift(bl_sam_buff_t *sam_buff, size_t nelem);
bool bl_sam_buff_alignment_ok(bl_sam_buff_t *sam_buff, bl_sam_t *sam_alignment);

#endif  // _BIOLIBC_SAM_BUFF_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_sam_buff_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-sam-buff-mutators.c */
int bl_sam_buff_set_buff_size(bl_sam_buff_t *bl_sam_buff_ptr, size_t new_buff_size);
int bl_sam_buff_set_max_alignments(bl_sam_buff_t *bl_sam_buff_ptr, size_t new_max_alignments);
int bl_sam_buff_set_alignments(bl_sam_buff_t *bl_sam_buff_ptr, bl_sam_t **new_alignments);
int bl_sam_buff_set_alignments_ae(bl_sam_buff_t *bl_sam_buff_ptr, size_t c, bl_sam_t *new_alignments_element);
int bl_sam_buff_set_alignments_cpy(bl_sam_buff_t *bl_sam_buff_ptr, bl_sam_t **new_alignments, size_t array_size);
int bl_sam_buff_set_buffered_count(bl_sam_buff_t *bl_sam_buff_ptr, size_t new_buffered_count);
int bl_sam_buff_set_max_count(bl_sam_buff_t *bl_sam_buff_ptr, size_t new_max_count);
int bl_sam_buff_set_previous_pos(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_previous_pos);
int bl_sam_buff_set_previous_rname_ae(bl_sam_buff_t *bl_sam_buff_ptr, size_t c, char new_previous_rname_element);
int bl_sam_buff_set_previous_rname_cpy(bl_sam_buff_t *bl_sam_buff_ptr, char new_previous_rname[], size_t array_size);
int bl_sam_buff_set_mapq_min(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_mapq_min);
int bl_sam_buff_set_mapq_low(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_mapq_low);
int bl_sam_buff_set_mapq_high(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_mapq_high);
int bl_sam_buff_set_mapq_sum(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_mapq_sum);
int bl_sam_buff_set_reads_used(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_reads_used);
int bl_sam_buff_set_total_alignments(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_total_alignments);
int bl_sam_buff_set_trailing_alignments(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_trailing_alignments);
int bl_sam_buff_set_discarded_alignments(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_discarded_alignments);
int bl_sam_buff_set_discarded_score_sum(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_discarded_score_sum);
int bl_sam_buff_set_discarded_trailing(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_discarded_trailing);
int bl_sam_buff_set_min_discarded_score(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_min_discarded_score);
int bl_sam_buff_set_max_discarded_score(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_max_discarded_score);
int bl_sam_buff_set_unmapped_alignments(bl_sam_buff_t *bl_sam_buff_ptr, int64_t new_unmapped_alignments);

/* Return values for mutator functions */
#define BL_SAM_BUFF_DATA_OK              0
#define BL_SAM_BUFF_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_SAM_BUFF_DATA_OUT_OF_RANGE    -2


// After bl_sam_t def due to mutual recursion
#ifndef _BIOLIBC_GFF_H_
#endif

/* sam.c */
FILE *bl_sam_skip_header(FILE *sam_stream);
int bl_sam_copy_header(FILE *header_stream, FILE *sam_stream);
int bl_sam_read(bl_sam_t *sam_alignment, FILE *sam_stream, sam_field_mask_t field_mask);
void bl_sam_copy(bl_sam_t *dest, bl_sam_t *src);
void bl_sam_free(bl_sam_t *sam_alignment);
void bl_sam_init(bl_sam_t *sam_alignment);
int bl_sam_write(bl_sam_t *sam_alignment, FILE *sam_stream, sam_field_mask_t field_mask);
FILE *bl_sam_fopen(const char *filename, const char *mode, char *samtools_flags);
int bl_sam_fclose(FILE *stream);
int64_t bl_sam_gff_overlap(bl_sam_t *alignment, bl_gff_t *feature);
int bl_sam_gff_cmp(bl_sam_t *alignment, bl_gff_t *feature);

#endif // _BIOLIBC_SAM_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_sam_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-sam-mutators.c */
int bl_sam_set_qname_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_qname_element);
int bl_sam_set_qname_cpy(bl_sam_t *bl_sam_ptr, char new_qname[], size_t array_size);
int bl_sam_set_flag(bl_sam_t *bl_sam_ptr, unsigned new_flag);
int bl_sam_set_rname_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_rname_element);
int bl_sam_set_rname_cpy(bl_sam_t *bl_sam_ptr, char new_rname[], size_t array_size);
int bl_sam_set_pos(bl_sam_t *bl_sam_ptr, int64_t new_pos);
int bl_sam_set_mapq(bl_sam_t *bl_sam_ptr, unsigned char new_mapq);
int bl_sam_set_cigar(bl_sam_t *bl_sam_ptr, char *new_cigar);
int bl_sam_set_cigar_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_cigar_element);
int bl_sam_set_cigar_cpy(bl_sam_t *bl_sam_ptr, char *new_cigar, size_t array_size);
int bl_sam_set_rnext_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_rnext_element);
int bl_sam_set_rnext_cpy(bl_sam_t *bl_sam_ptr, char new_rnext[], size_t array_size);
int bl_sam_set_pnext(bl_sam_t *bl_sam_ptr, int64_t new_pnext);
int bl_sam_set_tlen(bl_sam_t *bl_sam_ptr, long new_tlen);
int bl_sam_set_seq(bl_sam_t *bl_sam_ptr, char *new_seq);
int bl_sam_set_seq_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_seq_element);
int bl_sam_set_seq_cpy(bl_sam_t *bl_sam_ptr, char *new_seq, size_t array_size);
int bl_sam_set_qual(bl_sam_t *bl_sam_ptr, char *new_qual);
int bl_sam_set_qual_ae(bl_sam_t *bl_sam_ptr, size_t c, char new_qual_element);
int bl_sam_set_qual_cpy(bl_sam_t *bl_sam_ptr, char *new_qual, size_t array_size);
int bl_sam_set_cigar_array_size(bl_sam_t *bl_sam_ptr, size_t new_cigar_array_size);
int bl_sam_set_cigar_len(bl_sam_t *bl_sam_ptr, size_t new_cigar_len);
int bl_sam_set_seq_array_size(bl_sam_t *bl_sam_ptr, size_t new_seq_array_size);
int bl_sam_set_seq_len(bl_sam_t *bl_sam_ptr, size_t new_seq_len);
int bl_sam_set_qual_array_size(bl_sam_t *bl_sam_ptr, size_t new_qual_array_size);
int bl_sam_set_qual_len(bl_sam_t *bl_sam_ptr, size_t new_qual_len);

/* Return values for mutator functions */
#define BL_SAM_DATA_OK              0
#define BL_SAM_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_SAM_DATA_OUT_OF_RANGE    -2

#ifndef _BIOLIBC_TRANSLATE_H_
#define _BIOLIBC_TRANSLATE_H_

long   bl_next_start_codon(FILE *rna_stream, char codon[4]);
long   bl_next_stop_codon(FILE *rna_stream, char codon[4]);

#endif  // _BIOLIBC_TRANSLATE_H_
    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the bl_vcf_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define BL_VCF_CHROM(ptr)               ((ptr)->chrom)
#define BL_VCF_CHROM_AE(ptr,c)          ((ptr)->chrom[c])
#define BL_VCF_ID(ptr)                  ((ptr)->id)
#define BL_VCF_ID_AE(ptr,c)             ((ptr)->id[c])
#define BL_VCF_REF(ptr)                 ((ptr)->ref)
#define BL_VCF_REF_AE(ptr,c)            ((ptr)->ref[c])
#define BL_VCF_ALT(ptr)                 ((ptr)->alt)
#define BL_VCF_ALT_AE(ptr,c)            ((ptr)->alt[c])
#define BL_VCF_QUAL(ptr)                ((ptr)->qual)
#define BL_VCF_QUAL_AE(ptr,c)           ((ptr)->qual[c])
#define BL_VCF_FILTER(ptr)              ((ptr)->filter)
#define BL_VCF_FILTER_AE(ptr,c)         ((ptr)->filter[c])
#define BL_VCF_INFO(ptr)                ((ptr)->info)
#define BL_VCF_INFO_AE(ptr,c)           ((ptr)->info[c])
#define BL_VCF_FORMAT(ptr)              ((ptr)->format)
#define BL_VCF_FORMAT_AE(ptr,c)         ((ptr)->format[c])
#define BL_VCF_SINGLE_SAMPLE(ptr)       ((ptr)->single_sample)
#define BL_VCF_SINGLE_SAMPLE_AE(ptr,c)  ((ptr)->single_sample[c])
#define BL_VCF_MULTI_SAMPLES(ptr)       ((ptr)->multi_samples)
#define BL_VCF_MULTI_SAMPLES_AE(ptr,c)  ((ptr)->multi_samples[c])
#define BL_VCF_POS(ptr)                 ((ptr)->pos)
#define BL_VCF_INFO_ARRAY_SIZE(ptr)     ((ptr)->info_array_size)
#define BL_VCF_INFO_LEN(ptr)            ((ptr)->info_len)
#define BL_VCF_FORMAT_ARRAY_SIZE(ptr)   ((ptr)->format_array_size)
#define BL_VCF_FORMAT_LEN(ptr)          ((ptr)->format_len)
#define BL_VCF_SINGLE_SAMPLE_ARRAY_SIZE(ptr) ((ptr)->single_sample_array_size)
#define BL_VCF_SINGLE_SAMPLE_LEN(ptr)   ((ptr)->single_sample_len)
#define BL_VCF_MULTI_SAMPLE_POINTER_ARRAY_SIZE(ptr) ((ptr)->multi_sample_pointer_array_size)
#define BL_VCF_MULTI_SAMPLE_COUNT(ptr)  ((ptr)->multi_sample_count)
#define BL_VCF_MULTI_SAMPLE_ARRAY_SIZES(ptr) ((ptr)->multi_sample_array_sizes)
#define BL_VCF_MULTI_SAMPLE_ARRAY_SIZES_AE(ptr,c) ((ptr)->multi_sample_array_sizes[c])
#define BL_VCF_MULTI_SAMPLE_LENS(ptr)   ((ptr)->multi_sample_lens)
#define BL_VCF_MULTI_SAMPLE_LENS_AE(ptr,c) ((ptr)->multi_sample_lens[c])
#define BL_VCF_REF_COUNT(ptr)           ((ptr)->ref_count)
#define BL_VCF_ALT_COUNT(ptr)           ((ptr)->alt_count)
#define BL_VCF_OTHER_COUNT(ptr)         ((ptr)->other_count)
#define BL_VCF_PHREDS(ptr)              ((ptr)->phreds)
#define BL_VCF_PHREDS_AE(ptr,c)         ((ptr)->phreds[c])
#define BL_VCF_PHRED_COUNT(ptr)         ((ptr)->phred_count)
#define BL_VCF_PHRED_BUFF_SIZE(ptr)     ((ptr)->phred_buff_size)
#ifndef _BIOLIBC_VCF_H_
#define _BIOLIBC_VCF_H_

#ifndef _BIOLIBC_SAM_H_
#endif

#ifndef _BIOLIBC_H_
#endif

#ifndef _bool_true_false_are_defined
#include <stdbool.h>
#endif

/*
 *  vcfio is meant to provide a very simple and fast method for processing
 *  VCF streams one call at a time.  As such, there should generally be only
 *  one or a few bl_vcf_t structures substantiated at a given moment, and
 *  we can afford to be generous with the max sizes.
 *  If you're writing programs that inhale many VCF calls into memory, vcfio
 *  is not for you.
 */

// FIXME: Arbitrary guess
// Only used for temp variables.  Replace with read_field_malloc().
#define BL_VCF_SAMPLE_ID_MAX_CHARS    4096

// Hack:
// Use different sizes for each so dsv_read_field() buffer overflow errors
// will point to a specific field.  Eventually should have dsv_read_field()
// return an error code rather than exit with an error message
//#define BL_VCF_REF_MAX_CHARS        32
//#define BL_VCF_ALT_MAX_CHARS        33
//#define BL_VCF_QUAL_MAX_CHARS       34
//#define BL_VCF_FILTER_MAX_CHARS     64

// We actually saw INFO fields over 512k in some dbGap BCFs
typedef struct
{
    char        *chrom,
        *id,
        *ref,
        *alt,
        *qual,
        *filter,
        *info,
        *format,
        *single_sample,     // Simpler than using multi_samples
        **multi_samples;
    int64_t     pos;
    size_t      chrom_array_size,
        chrom_len,
        id_array_size,
        id_len,
        ref_array_size,
        ref_len,
        alt_array_size,
        alt_len,
        qual_array_size,
        qual_len,
        filter_array_size,
        filter_len,
        info_array_size,
        info_len,
        format_array_size,
        format_len,
        single_sample_array_size,
        single_sample_len,
        multi_sample_pointer_array_size,
        multi_sample_count,
        *multi_sample_array_sizes,
        *multi_sample_lens;
    unsigned    ref_count,
        alt_count,
        other_count;
    
    // Apps can buffer phred scores from reads to collect stats
    unsigned char   *phreds;
    size_t          phred_count;
    size_t          phred_buff_size;
}   bl_vcf_t;

typedef unsigned int vcf_field_mask_t;

#define BL_VCF_FIELD_ALL        0xfff
#define BL_VCF_FIELD_CHROM      0x001
#define BL_VCF_FIELD_POS        0x002
#define BL_VCF_FIELD_ID         0x004
#define BL_VCF_FIELD_REF        0x008
#define BL_VCF_FIELD_ALT        0x010
#define BL_VCF_FIELD_QUAL       0x020
#define BL_VCF_FIELD_FILTER     0x040
#define BL_VCF_FIELD_INFO       0x080
#define BL_VCF_FIELD_FORMAT     0x100
#define BL_VCF_FIELD_ERROR      0x000


/* vcf.c */
FILE *bl_vcf_skip_meta_data(FILE *vcf_stream);
FILE *bl_vcf_skip_header(FILE *vcf_stream);
void bl_vcf_get_sample_ids(FILE *vcf_stream, char *sample_ids[], size_t first_col, size_t last_col);
int bl_vcf_read_static_fields(bl_vcf_t *vcf_call, FILE *vcf_stream, vcf_field_mask_t field_mask);
int bl_vcf_read_ss_call(bl_vcf_t *vcf_call, FILE *vcf_stream, vcf_field_mask_t field_mask);
int bl_vcf_write_static_fields(bl_vcf_t *vcf_call, FILE *vcf_stream, vcf_field_mask_t field_mask);
int bl_vcf_write_ss_call(bl_vcf_t *vcf_call, FILE *vcf_stream, vcf_field_mask_t field_mask);
char **bl_vcf_sample_alloc(bl_vcf_t *vcf_call, size_t samples);
void bl_vcf_free(bl_vcf_t *vcf_call);
void bl_vcf_init(bl_vcf_t *vcf_call);
vcf_field_mask_t bl_vcf_parse_field_spec(char *spec);
_Bool bl_vcf_call_in_alignment(bl_vcf_t *vcf_call, bl_sam_t *sam_alignment);
_Bool bl_vcf_call_downstream_of_alignment(bl_vcf_t *vcf_call, bl_sam_t *alignment);
void bl_vcf_call_out_of_order(bl_vcf_t *vcf_call, char *previous_chrom, int64_t previous_pos);

#endif // _BIOLIBC_VCF_H_

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator functions for setting with no sanity checking.  Use these to
 *  set structure members from functions outside the bl_vcf_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

/* temp-vcf-mutators.c */
int bl_vcf_set_chrom_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_chrom_element);
int bl_vcf_set_chrom_cpy(bl_vcf_t *bl_vcf_ptr, char new_chrom[], size_t array_size);
int bl_vcf_set_id_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_id_element);
int bl_vcf_set_id_cpy(bl_vcf_t *bl_vcf_ptr, char new_id[], size_t array_size);
int bl_vcf_set_ref_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_ref_element);
int bl_vcf_set_ref_cpy(bl_vcf_t *bl_vcf_ptr, char new_ref[], size_t array_size);
int bl_vcf_set_alt_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_alt_element);
int bl_vcf_set_alt_cpy(bl_vcf_t *bl_vcf_ptr, char new_alt[], size_t array_size);
int bl_vcf_set_qual_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_qual_element);
int bl_vcf_set_qual_cpy(bl_vcf_t *bl_vcf_ptr, char new_qual[], size_t array_size);
int bl_vcf_set_filter_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_filter_element);
int bl_vcf_set_filter_cpy(bl_vcf_t *bl_vcf_ptr, char new_filter[], size_t array_size);
int bl_vcf_set_info(bl_vcf_t *bl_vcf_ptr, char *new_info);
int bl_vcf_set_info_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_info_element);
int bl_vcf_set_info_cpy(bl_vcf_t *bl_vcf_ptr, char *new_info, size_t array_size);
int bl_vcf_set_format(bl_vcf_t *bl_vcf_ptr, char *new_format);
int bl_vcf_set_format_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_format_element);
int bl_vcf_set_format_cpy(bl_vcf_t *bl_vcf_ptr, char *new_format, size_t array_size);
int bl_vcf_set_single_sample(bl_vcf_t *bl_vcf_ptr, char *new_single_sample);
int bl_vcf_set_single_sample_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char new_single_sample_element);
int bl_vcf_set_single_sample_cpy(bl_vcf_t *bl_vcf_ptr, char *new_single_sample, size_t array_size);
int bl_vcf_set_multi_samples(bl_vcf_t *bl_vcf_ptr, char **new_multi_samples);
int bl_vcf_set_multi_samples_ae(bl_vcf_t *bl_vcf_ptr, size_t c, char *new_multi_samples_element);
int bl_vcf_set_multi_samples_cpy(bl_vcf_t *bl_vcf_ptr, char **new_multi_samples, size_t array_size);
int bl_vcf_set_pos(bl_vcf_t *bl_vcf_ptr, int64_t new_pos);
int bl_vcf_set_info_array_size(bl_vcf_t *bl_vcf_ptr, size_t new_info_array_size);
int bl_vcf_set_info_len(bl_vcf_t *bl_vcf_ptr, size_t new_info_len);
int bl_vcf_set_format_array_size(bl_vcf_t *bl_vcf_ptr, size_t new_format_array_size);
int bl_vcf_set_format_len(bl_vcf_t *bl_vcf_ptr, size_t new_format_len);
int bl_vcf_set_single_sample_array_size(bl_vcf_t *bl_vcf_ptr, size_t new_single_sample_array_size);
int bl_vcf_set_single_sample_len(bl_vcf_t *bl_vcf_ptr, size_t new_single_sample_len);
int bl_vcf_set_multi_sample_pointer_array_size(bl_vcf_t *bl_vcf_ptr, size_t new_multi_sample_pointer_array_size);
int bl_vcf_set_multi_sample_count(bl_vcf_t *bl_vcf_ptr, size_t new_multi_sample_count);
int bl_vcf_set_multi_sample_array_sizes(bl_vcf_t *bl_vcf_ptr, size_t *new_multi_sample_array_sizes);
int bl_vcf_set_multi_sample_array_sizes_ae(bl_vcf_t *bl_vcf_ptr, size_t c, size_t new_multi_sample_array_sizes_element);
int bl_vcf_set_multi_sample_array_sizes_cpy(bl_vcf_t *bl_vcf_ptr, size_t *new_multi_sample_array_sizes, size_t array_size);
int bl_vcf_set_multi_sample_lens(bl_vcf_t *bl_vcf_ptr, size_t *new_multi_sample_lens);
int bl_vcf_set_multi_sample_lens_ae(bl_vcf_t *bl_vcf_ptr, size_t c, size_t new_multi_sample_lens_element);
int bl_vcf_set_multi_sample_lens_cpy(bl_vcf_t *bl_vcf_ptr, size_t *new_multi_sample_lens, size_t array_size);
int bl_vcf_set_ref_count(bl_vcf_t *bl_vcf_ptr, unsigned new_ref_count);
int bl_vcf_set_alt_count(bl_vcf_t *bl_vcf_ptr, unsigned new_alt_count);
int bl_vcf_set_other_count(bl_vcf_t *bl_vcf_ptr, unsigned new_other_count);
int bl_vcf_set_phreds(bl_vcf_t *bl_vcf_ptr, unsigned char *new_phreds);
int bl_vcf_set_phreds_ae(bl_vcf_t *bl_vcf_ptr, size_t c, unsigned char new_phreds_element);
int bl_vcf_set_phreds_cpy(bl_vcf_t *bl_vcf_ptr, unsigned char *new_phreds, size_t array_size);
int bl_vcf_set_phred_count(bl_vcf_t *bl_vcf_ptr, size_t new_phred_count);
int bl_vcf_set_phred_buff_size(bl_vcf_t *bl_vcf_ptr, size_t new_phred_buff_size);

/* Return values for mutator functions */
#define BL_VCF_DATA_OK              0
#define BL_VCF_DATA_INVALID         -1      // Catch-all for non-specific error
#define BL_VCF_DATA_OUT_OF_RANGE    -2

